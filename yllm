#!/bin/bash

# Define the API URL and Authorization token
API_URL="https://api.fireworks.ai/inference/v1/chat/completions"
AUTH_TOKEN="Bearer $YLLM_API_KEY"

# Default model
#MODEL="accounts/fireworks/models/mixtral-8x7b-instruct"
MODEL="accounts/fireworks/models/yi-34b-200k-capybara"
MAX_TOKENS=4096
TEMPERATURE=0.1
TOP_P=0.9

function print_help() {
  cat <<EOF
Usage: $0 [options] [--] [prompt]

Options:
  -h, --help                Print this help text and exit.
  -a, --api-url <url>       The API URL to use (default: $API_URL).
  -m, --model <model>       The model to use for the completion (default: $MODEL).
  -t, --temperature <t      The temperature for the model (default: $TEMPERATURE).
  -p, --top-p <p>           The top-p value for the model (default: $TOP_P).
  -l, --max-tokens <n>      The maximum number of tokens to generate (default: $MAX_TOKENS).
  -c, --stdin               Read data from standard input, put before prompt.
  -u, --url <url>           Read text data from the given URL, put before prompt.
  -f, --file <file>         Read text data from the given file, put before prompt.

If no prompt is provided, read from standard input.
EOF
}

# no arguments, print help
if [[ $# -eq 0 ]]; then
  print_help
  exit 0
fi

# Parse command line arguments and flags
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            print_help
            exit 0
            ;;
        -a|--api-url)
            API_URL="$2"
            shift # past argument
            shift # past value
            ;;
        -m|--model)
            MODEL="$2"
            shift # past argument
            shift # past value
            ;;
        -t|--temperature)
            TEMPERATURE="$2"
            shift # past argument
            shift # past value
            ;;
        -p|--top-p)
            TOP_P="$2"
            shift # past argument
            shift # past value
            ;;
        -l|--max-tokens)
            MAX_TOKENS="$2"
            shift # past argument
            shift # past value
            ;;
        -c|--stdin)
            STDIN_CONTENT=true
            shift # past argument
            ;;
        -u|--url)
            URL="$2"
            shift # past argument
            shift # past value
            ;;
        -f|--file)
            FILE="$2"
            shift # past argument
            shift # past value
            ;;
        *)
            if [[ -z $PROMPT ]]; then
                PROMPT="$1"
            else
                PROMPT="$PROMPT $1"
            fi
            shift # past argument
            ;;
    esac
done

unbuffer="stdbuf -o0 -i0"

send_request() {
    prompt="$1"
    json_payload=$(printf '{
        "messages": [
            {
                "role": "user",
                "content": %s
            }
        ],
        "model": "%s",
        "stream": true,
        "n": 1,
        "max_tokens": %d,
        "temperature": %.2f,
        "top_p": %.2f,
        "stop": []
    }' "$prompt" "$MODEL" $MAX_TOKENS $TEMPERATURE $TOP_P)

    $unbuffer curl --request POST \
         --silent \
         --url "$API_URL" \
         -H 'Content-Type: application/json' \
         -H "Authorization: $AUTH_TOKEN" \
         --data "$json_payload"
}

# Build the complete prompt
if [[ -n $STDIN_CONTENT ]]; then
    COMPLETE_PROMPT=$( (cat ; echo $PROMPT)  | jq -sR .)
elif [[ -n $URL ]]; then
         COMPLETE_PROMPT=$( (curl -s $URL | lynx -stdin -dump ; echo $PROMPT)  | jq -sR .)
elif [[ -n $FILE ]]; then
    # if the file is text, dump it
    if [[ $(file -b --mime-type "$FILE") == text/* ]]; then
        COMPLETE_PROMPT=$( (cat "$FILE" ; echo $PROMPT)  | jq -sR .)
    # if it's a pdf, convert to text with pdftotext
    elif [[ $(file -b --mime-type "$FILE") == "application/pdf" ]]; then
        COMPLETE_PROMPT=$( (pdftotext "$FILE" - ; echo $PROMPT)  | jq -sR .)
    # if it's a docx, convert to text with pandoc
    elif [[ $(file -b --mime-type "$FILE") == "application/vnd.openxmlformats-officedocument.wordprocessingml.document" ]] || [[ $(file -b --mime-type "$FILE") == "application/msword" ]]; then
        COMPLETE_PROMPT=$( ( pandoc -s "$FILE" -t plain -o - ; echo $PROMPT)  | jq -sR .)
    else
        echo "Unsupported file type: $(file -b --mime-type "$FILE")"
        exit 1
    fi
else
    COMPLETE_PROMPT=$( echo $PROMPT | jq -sR .)
fi

# Send the request and extract the response
send_request "$COMPLETE_PROMPT" \
    | $unbuffer sed 's/^data: //g' | $unbuffer sed 's/\[DONE\]//' \
    | $unbuffer jq -j --unbuffered 'select(.choices[0].delta.content != null) | .choices[0].delta.content'
